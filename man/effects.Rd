% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/effects.R
\name{effects}
\alias{effects}
\title{Add an effect size to a fitted comparison}
\usage{
effects(spec, conf_level = 0.95, effect = "default")
}
\arguments{
\item{spec}{A \code{comp_spec} created by \code{\link[=comp_spec]{comp_spec()}} and already fitted
via \code{test()} (i.e., \code{spec$fitted} must exist). Roles must include a
numeric outcome and a two‑level group.}

\item{conf_level}{Confidence level for the interval (numeric in (0, 1),
default \code{0.95}).}

\item{effect}{Optional override for some engines. Currently, only
\code{effect = "cohens_d"} is supported for the \code{welch_t} engine to
compute Cohen's \emph{d} instead of Hedges' \emph{g}.}
}
\value{
The input \code{spec}, updated in place with effect‑size fields in
\code{spec$fitted}: \code{es_value}, \code{es_conf_low}, \code{es_conf_high}, \code{es_metric}.
}
\description{
Compute an effect size (with a confidence interval) for a two‑group,
numeric outcome based on the inferential engine stored in
\code{spec$fitted$engine}. Supported tests map to the following metrics:
}
\details{
\itemize{
\item \code{"student_t"}: Cohen's \emph{d} (no Hedges correction)
\item \code{"welch_t"}: Hedges' \emph{g} (default) or Cohen's \emph{d} when
\code{effect = "cohens_d"}
\item \code{"mann_whitney"}: Wilcoxon \emph{r} (rank biserial)
\item \code{"paired_t"}: Cohen's \emph{d} for paired samples
\item \code{"wilcoxon_signed_rank"}: Wilcoxon \emph{r} (rank biserial)
}

The function reads from \code{spec$fitted} and writes \code{es_value},
\code{es_conf_low}, \code{es_conf_high}, and \code{es_metric} before returning \code{spec}.
\itemize{
\item Supported design: two‑group comparison with a \strong{numeric} outcome.
\item Backend functions from the
\href{https://easystats.github.io/effectsize/}{\code{effectsize}} package
(e.g., \code{hedges_g()}, \code{cohens_d()}, \code{rank_biserial()}).
\item If the \strong{effectsize} package is not installed, a warning is issued
and the input \code{spec} is returned unchanged.
}

The function selects \code{spec$data_prepared} when available, otherwise
falls back to \code{spec$data_raw}. It standardizes inputs internally and
then calls the appropriate effect size function based on
\code{spec$fitted$engine}.
}
\examples{
# Minimal workflow (illustrative):
spec <- comp_spec(mtcars)
spec$roles <- list(outcome = "mpg", group = "am")  # am has two levels
spec$outcome_type <- "numeric"

# Pretend we've run the inferential test step that creates `spec$fitted`
# (your package's `test()` function). Then add effect size:
# spec <- test(spec)
# spec <- effects(spec, conf_level = 0.90)
#
# Access results:
# spec$fitted$es_value
# spec$fitted$es_conf_low
# spec$fitted$es_conf_high
# spec$fitted$es_metric

}
\seealso{
\code{\link[=comp_spec]{comp_spec()}}, diagnose(), test()
}
