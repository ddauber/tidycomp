% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnose.R
\name{diagnose}
\alias{diagnose}
\title{Diagnose a comparison specification (non-destructive)}
\usage{
diagnose(spec)
}
\arguments{
\item{spec}{A \code{comp_spec} with roles/design/outcome type already set.
Must include at least an outcome variable and a group variable in
\code{spec$roles}.}
}
\value{
The input \code{spec}, updated with a \code{diagnostics} list.
}
\description{
Run lightweight checks on a \code{comp_spec}. For numeric outcomes this includes
group sizes, variance heterogeneity (Brown--Forsythe proxy), within-group normality (Shapiro),
and simple IQR-based outlier counts. For binary outcomes it inspects the contingency
table between outcome and group to determine whether chi-squared assumptions hold
or if an exact test is recommended. The function \strong{does not} alter the raw data; it attaches a \code{diagnostics} list to the spec.
}
\details{
For numeric outcomes, the following summaries are stored in \code{spec$diagnostics}:
\itemize{
\item \code{group_sizes}: a tibble with counts per group.
\item \code{var_bf_p}: Brown-Forsythe proxy p-value for variance heterogeneity.
\item \code{normality}: per-group Shapiro-Wilk p-values (flagged only; not enforced).
\item \code{sphericity}: Mauchly p-values for repeated-measures designs.
\item \code{notes}: human-readable notes highlighting potential issues
(e.g., small groups, variance heterogeneity, non-normality, outliers).
}

For binary outcomes, diagnostics include:
\itemize{
\item \code{table}: the observed contingency table.
\item \code{expected}: expected counts (when available).
\item \code{engine}: recommended engine based on cell counts.
\item \code{notes}: notes on small cells or other issues.
}

These diagnostics are intended as \strong{signals} to guide strategy/engine
choices (e.g., robust/permutation) rather than hard pass/fail gates.
}
\examples{
# setup
spec <- comp_spec(mtcars)
spec$roles <- list(outcome = "am", group = "cyl")
spec$design <- "independent"
spec$outcome_type <- "binary"
spec <- diagnose(spec)
spec$diagnostics$engine
}
